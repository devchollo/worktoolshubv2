// routes/imageRoutes.js
const express = require('express');
const router = express.Router();
const { Validator } = require('../utils/validation');

class ImageGenerationService {
  constructor() {
    this.apiKey = process.env.GEMINI_API_KEY;
    // Correct endpoint for Gemini Imagen 3 (uses generateContent method, not predict)
    this.model = 'imagen-3.0';
    this.baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent`;
  }

  sanitizePrompt(prompt) {
    if (!prompt) return '';
    
    let cleaned = String(prompt).trim();
    
    // Remove potential prompt injection patterns
    cleaned = cleaned.replace(/ignore previous instructions/gi, '[filtered]');
    cleaned = cleaned.replace(/system:|assistant:|user:/gi, '[filtered]');
    
    // Limit length
    cleaned = cleaned.substring(0, 2000);
    
    return cleaned;
  }

  enhancePrompt(prompt, style) {
    const styleEnhancements = {
      photorealistic: 'photorealistic, high detail, professional photography, 8k resolution, sharp focus',
      artistic: 'artistic style, creative composition, vibrant colors, expressive, beautiful artwork',
      minimalist: 'minimalist design, clean lines, simple composition, modern, elegant',
      abstract: 'abstract art, geometric shapes, creative patterns, artistic expression, contemporary'
    };

    const enhancement = styleEnhancements[style] || styleEnhancements.photorealistic;
    return `${prompt}, ${enhancement}`;
  }

  getAspectRatio(size) {
    // Map sizes to Gemini's aspect ratio format
    const ratioMap = {
      '1024x1024': '1:1',
      '1024x1792': '9:16',
      '1792x1024': '16:9'
    };
    return ratioMap[size] || '1:1';
  }

  async generateImages(prompt, style = 'photorealistic', size = '1024x1024', numImages = 1) {
  if (!this.apiKey) {
    throw new Error('Gemini API key not configured');
  }

  const safePrompt = this.sanitizePrompt(prompt);
  const enhancedPrompt = this.enhancePrompt(safePrompt, style);
  const aspectRatio = this.getAspectRatio(size);

  console.log(`ðŸŽ¨ Generating ${numImages} image(s) with Gemini Imagen 3...`);
  console.log(`ðŸ“ Prompt: ${enhancedPrompt.substring(0, 100)}...`);
  console.log(`ðŸ“ Aspect Ratio: ${aspectRatio}`);

  try {
    // âœ… Correct endpoint for Imagen 3
    this.model = 'imagen-3.0';
    this.baseUrl = `https://generativelanguage.googleapis.com/v1/models/${this.model}:generateContent`;

    // âœ… Correct body format for Gemini Imagen 3
    const requestBody = {
      contents: [
        {
          role: "user",
          parts: [{ text: enhancedPrompt }]
        }
      ],
      generationConfig: {
        temperature: 0.4,
        candidateCount: Math.min(numImages, 4)
      }
    };

    console.log('ðŸ“¤ Sending request to Gemini Imagen API...');
    console.log('ðŸ“ URL:', `${this.baseUrl}?key=***`);

    const response = await fetch(
      `${this.baseUrl}?key=${this.apiKey}`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      }
    );

    const responseText = await response.text();
    console.log(`ðŸ“¥ API Response Status: ${response.status}`);

    if (!response.ok) {
      console.error('âŒ Gemini API Error Response:', responseText.substring(0, 500));
      let errorData;
      try {
        errorData = JSON.parse(responseText);
      } catch (e) {
        errorData = { message: responseText };
      }
      const errorMessage = errorData.error?.message || errorData.message || `API error: ${response.status}`;
      throw new Error(errorMessage);
    }

    let data;
    try {
      data = JSON.parse(responseText);
    } catch (e) {
      console.error('âŒ Failed to parse response:', responseText.substring(0, 200));
      throw new Error('Invalid response from image generation API');
    }

    console.log('âœ… Successfully parsed API response');
    console.log('ðŸ“Š Response keys:', Object.keys(data).join(', '));

    // âœ… Parse Imagen 3 response structure
    const candidates = data.candidates || [];
    const images = [];

    for (const candidate of candidates) {
      const parts = candidate.content?.parts || [];
      for (const part of parts) {
        if (part.inline_data?.mime_type?.startsWith('image/')) {
          images.push({
            url: `data:${part.inline_data.mime_type};base64,${part.inline_data.data}`,
            mimeType: part.inline_data.mime_type
          });
        }
      }
    }

    if (images.length === 0) {
      console.error('âŒ No images found in API response');
      throw new Error('No images were generated by the API');
    }

    console.log(`âœ… Successfully generated ${images.length} image(s)`);
    return images;

  } catch (error) {
    console.error('âŒ Image generation error:', error.message);
    console.error('âŒ Full error:', error);

    if (error.message.includes('API key')) {
      throw new Error('Invalid or missing API key');
    } else if (error.message.includes('not found') || error.message.includes('not supported')) {
      throw new Error('Image generation model is not available. Please check API configuration.');
    } else if (error.message.includes('quota') || error.message.includes('RESOURCE_EXHAUSTED')) {
      throw new Error('API quota exceeded. Please try again later.');
    } else if (error.message.includes('safety') || error.message.includes('blocked')) {
      throw new Error('Content blocked by safety filters. Please try a different prompt.');
    } else if (error.message.includes('Invalid response')) {
      throw error;
    } else {
      throw new Error(`Generation failed: ${error.message}`);
    }
  }
}

}

const imageService = new ImageGenerationService();

// POST /api/images/generate - Generate images with AI
router.post('/generate', async (req, res) => {
  try {
    const { prompt, style = 'photorealistic', size = '1024x1024', numImages = 1 } = req.body;

    console.log('ðŸ“¸ Received image generation request');
    console.log('   Prompt:', prompt?.substring(0, 50) + '...');
    console.log('   Style:', style);
    console.log('   Size:', size);
    console.log('   Count:', numImages);

    // Validate prompt
    if (!prompt || !prompt.trim()) {
      return res.status(400).json({
        error: 'Validation failed',
        message: 'Prompt is required'
      });
    }

    // Sanitize inputs
    const sanitizedPrompt = Validator.sanitizeInput(prompt);

    // Validate prompt length
    if (sanitizedPrompt.length < 3) {
      return res.status(400).json({
        error: 'Validation failed',
        message: 'Prompt must be at least 3 characters long'
      });
    }

    if (sanitizedPrompt.length > 2000) {
      return res.status(400).json({
        error: 'Validation failed',
        message: 'Prompt is too long (max 2000 characters)'
      });
    }

    // Validate style
    const validStyles = ['photorealistic', 'artistic', 'minimalist', 'abstract'];
    if (!validStyles.includes(style)) {
      return res.status(400).json({
        error: 'Validation failed',
        message: 'Invalid style selected'
      });
    }

    // Validate size
    const validSizes = ['1024x1024', '1024x1792', '1792x1024'];
    if (!validSizes.includes(size)) {
      return res.status(400).json({
        error: 'Validation failed',
        message: 'Invalid size selected'
      });
    }

    // Validate number of images
    const safeNumImages = Math.min(Math.max(parseInt(numImages) || 1, 1), 4);

    console.log('âœ… Validation passed, generating images...');

    // Generate images
    const images = await imageService.generateImages(
      sanitizedPrompt,
      style,
      size,
      safeNumImages
    );

    console.log('âœ… Sending success response with', images.length, 'images');

    res.json({
      success: true,
      images: images,
      prompt: sanitizedPrompt,
      style: style,
      size: size,
      count: images.length
    });

  } catch (error) {
    console.error('âŒ Image generation endpoint error:', error.message);

    if (error.message.includes('API key')) {
      return res.status(503).json({
        error: 'Service unavailable',
        message: 'Image generation service is not configured properly. Please contact administrator.'
      });
    }

    if (error.message.includes('model is not available')) {
      return res.status(503).json({
        error: 'Service unavailable',
        message: 'The AI image generation model is currently unavailable. Please try again later.'
      });
    }

    if (error.message.includes('quota') || error.message.includes('limit')) {
      return res.status(429).json({
        error: 'Rate limit exceeded',
        message: 'Too many requests. Please try again later.'
      });
    }

    if (error.message.includes('safety') || error.message.includes('blocked')) {
      return res.status(400).json({
        error: 'Content policy violation',
        message: 'Your prompt was blocked by content safety filters. Please try a different prompt.'
      });
    }

    res.status(500).json({
      error: 'Generation failed',
      message: error.message || 'Failed to generate images. Please try again.'
    });
  }
});

// POST /api/images/upscale - Upscale an existing image (placeholder)
router.post('/upscale', async (req, res) => {
  try {
    const { imageUrl } = req.body;

    if (!imageUrl) {
      return res.status(400).json({
        error: 'Image URL is required'
      });
    }

    // TODO: Implement actual upscaling logic
    res.status(501).json({
      error: 'Not implemented',
      message: 'Image upscaling feature is coming soon!'
    });

  } catch (error) {
    console.error('Upscale error:', error);
    res.status(500).json({
      error: 'Upscaling failed'
    });
  }
});

// GET /api/images/health - Health check
router.get('/health', (req, res) => {
  const isConfigured = !!process.env.GEMINI_API_KEY;
  
  res.json({
    status: isConfigured ? 'OK' : 'Misconfigured',
    service: 'AI Image Generation',
    model: 'Gemini Imagen 3.0',
    endpoint: 'imagen-3.0-generate-001:generateImages',
    timestamp: new Date().toISOString(),
    geminiApi: isConfigured ? 'Configured' : 'Not configured',
    supportedStyles: ['photorealistic', 'artistic', 'minimalist', 'abstract'],
    supportedSizes: ['1024x1024', '1024x1792', '1792x1024'],
    maxImages: 4,
    note: 'Using Gemini Imagen 3.0 API'
  });
});

module.exports = router;